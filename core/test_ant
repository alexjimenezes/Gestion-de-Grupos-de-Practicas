

class BreakPairServiceTests(ServiceBaseTest):
    "test related with breaking pairs"
    def test30_breakpair_no_login(self):
        "try to breakpair without login first"
        # logout"
        self.client1.get(reverse(LOGOUT_SERVICE), follow=True)
        response = self.client1.get(reverse(BREAK_SERVICE), follow=True)
        self.is_login(response)

    def test31_novalidated_breakpair(self):
        """test break pair simple case:
        a) login
        b) created NOT validated pair
        c) break pair
        """
        # create simple pair
        # with validated = False
        p = Pair(student1=self.user1, student2=self.user2)
        p.save()
        pid = p.id
        # login 1 user
        self.loginTestUser(self.client1, self.user1)
        # ask for break page
        response = self.client1.get(reverse(BREAK_SERVICE), follow=True)
        # check landing page is OK
        self.is_break_pair(response)
        # check list of users is OK
        m = re.search(self.user1.first_name, self.decode(response.content))
        self.assertTrue(m)
        m = re.search(self.user2.first_name, self.decode(response.content))
        self.assertTrue(m)
        m = re.search(self.user3.first_name, self.decode(response.content))
        self.assertFalse(m)
        m = re.search(self.user4.first_name, self.decode(response.content))
        self.assertFalse(m)
        # POST call to BREAK_SERVICE
        data = {BREAK_FORM_LABEL: pid}
        response = self.client1.post(reverse(BREAK_SERVICE),
                                     data=data,
                                     follow=True)
        self.assertFalse(Pair.objects.filter(pk=pid).exists())

    def test32_validated_breakpair_first_user(self):
        """test break pair simple case:
        a) login
        b) created NOT validated p√†ir
        c) break pair
        """
        # create simple pair
        # with validated = False
        p = Pair(student1=self.user1, student2=self.user2, validated=True)
        p.save()
        pid = p.id
        # login 2 users
        self.loginTestUser(self.client1, self.user1)
        self.loginTestUser(self.client2, self.user2)
        self.assertIsNone(Pair.objects.get(pk=pid).studentBreakRequest)
        # POST call to BREAK_SERVICE
        # user1
        data = {BREAK_FORM_LABEL: pid}
        self.client1.post(reverse(BREAK_SERVICE),
                          data=data,
                          follow=True)
        self.assertTrue(Pair.objects.filter(pk=pid).exists())
        # check studentBreak is active
        self.assertTrue(Pair.objects.get(pk=pid).studentBreakRequest ==
                        self.user1)
        # user2
        self.client2.post(reverse(BREAK_SERVICE),
                          data=data,
                          follow=True)
        # check pair has been deleted
        self.assertFalse(Pair.objects.filter(pk=pid).exists())

    def test33_validated_breakpair_second_user(self):
        """As previous cse but user 2 beaks the pair
        """
        # create simple pair
        # with validated = True
        p = Pair(student1=self.user1, student2=self.user2, validated=True)
        p.save()
        pid = p.id
        # login 2 users
        self.loginTestUser(self.client1, self.user1)
        self.loginTestUser(self.client2, self.user2)
        self.assertIsNone(Pair.objects.get(pk=pid).studentBreakRequest)
        # POST call to BREAK_SERVICE
        # user2
        data = {BREAK_FORM_LABEL: pid}
        self.client2.post(reverse(BREAK_SERVICE),
                          data=data,
                          follow=True)
        self.assertTrue(Pair.objects.filter(pk=pid).exists())
        # check studentBreak is active
        self.assertTrue(Pair.objects.get(pk=pid).studentBreakRequest ==
                        self.user2)
        # user1
        self.client1.post(reverse(BREAK_SERVICE),
                          data=data,
                          follow=True)
        # check pair has been deleted
        self.assertFalse(Pair.objects.filter(pk=pid).exists())

    def test34_validated_breakpair_user_twice_requested(self):
        """user 1 and user 2 has requested user 3 as pair
        user 3 has accepted user 2 request
        break all pairs
        """
        # first pair with  validated = False
        p = Pair(student1=self.user1, student2=self.user3, validated=False)
        p.save()
        p1id = p.id
        # second pair with  validated = True
        p = Pair(student1=self.user2, student2=self.user3, validated=True)
        p.save()
        p2id = p.id

        # login 3 users
        self.loginTestUser(self.client1, self.user1)
        self.loginTestUser(self.client2, self.user2)
        self.loginTestUser(self.client3, self.user3)

        # assert pairs
        self.assertIsNone(Pair.objects.get(pk=p1id).studentBreakRequest)
        self.assertIsNone(Pair.objects.get(pk=p2id).studentBreakRequest)
        # POST call to BREAK_SERVICE
        # user2 tries to break second pair
        data = {BREAK_FORM_LABEL: p2id}
        self.client2.post(reverse(BREAK_SERVICE),
                          data=data,
                          follow=True)
        # but will not be broken until user3 breaks it too
        self.assertTrue(Pair.objects.filter(pk=p2id).exists())
        # check studentBreak is active
        self.assertTrue(Pair.objects.get(pk=p2id).studentBreakRequest ==
                        self.user2)
        # user 1 break pair, since it is not validated is OK
        data = {BREAK_FORM_LABEL: p1id}
        self.client1.post(reverse(BREAK_SERVICE),
                          data=data,
                          follow=True)
        # check pair has been deleted
        self.assertFalse(Pair.objects.filter(pk=p1id).exists())

        # finally user 3 breaks second pair
        data = {BREAK_FORM_LABEL: p2id}
        self.client3.post(reverse(BREAK_SERVICE),
                          data=data,
                          follow=True)
        # check pair has been deleted
        self.assertFalse(Pair.objects.filter(pk=p2id).exists())

    def test35_break_nonexisting_pair(self):
        """test pair that does not exists
        """
        # login
        self.loginTestUser(self.client1, self.user1)
        # send wrong pait id
        data = {BREAK_FORM_LABEL: 123456}
        response = self.client1.post(reverse(BREAK_SERVICE),
                                     data=data,
                                     follow=True)
        self.assertFalse(
            self.decode(response.content).find(PAIR_SELECTION_ERROR)==-1)